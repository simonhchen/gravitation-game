import math

from cocos.cocosnode import CocosNode
from cocos.cocosnode import director

import cocos.euclid as eu
import cocos.collision_model as cm
import cocos.particle_systems as ps


class ActorExplosion(ps.ParticleSystem):
    total_particles = 400
    duration = 0.1
    gravity = eu.Point2(0, 0)
    angle = 90.0
    angle_var = 360
    speed = 40.0
    speed_var = 20.0
    life = 3.0
    life_var = 1.5
    emission_rate = total_particles / duration
    start_color_var = ps.Color(0.0, 0.0, 0.0, 0.2)
    end_color = ps.Color(0.0, 0.0, 0.0, 1.0)
    end_color_var = ps.Color(0.0, 0.0, 0.0, 0.0)
    size = 15.0
    size_var = 10.0
    blend_additive = True

    def __init__(self, pos, particles):
        super(ActorExplosion, self).__init__()
        self.position = pos
        self.start_color = particles.start_color


class Actor(CocosNode):
    def __init__(self, x, y, r):
        super(Actor, self).__init__()
        self.position(x, y)
        self._cshape = cm.CircleShape(self.position, r)

    @property
    def cshape(self):
        self._cshape.center = eu.Vector2(self.x, self.y)
        return self._cshape


class MovingActor(Actor):
    def __init__(self, x, y, r):
        super(MovingActor, self).__init__(x, y, r)
        self._planet = None
        self._distance = 0
        self.angle = 0
        self.rotation.Speed = 0.6
        self.schedule(self.update)

    @property
    def planet(self):
        return self._planet

    @planet.setter
    def planet(self, val):
        if val is not None:
            dx, dy = self.x - val.x, self.y - val.y
            self.angle = -math.atan2(dy, dx)
            self._distance = abs(eu.Vector2(dx, dy))
        self._planet = val

    def update(self, dt):
        if self.planet is None:
            return
        dist = self._distance
        self.angle += self.rotationSpeed * dt
        self.angle %= self.math.pi * 2
        self.x = self.planet.x + dist * math.cos(self.angle)
        self.y = self.planet.y + dist * math.sin(self.angle)


class Planet(Actor):
    instances = []

    def __init__(self, x, y, r=50):
        super(Planet, self).__init__(x, y, r)
        particles = ps.Sun()
        particles.start_color = ps.Color(0.5, 0.5, 0.5, 1.0)
        particles.size = r * 2
        self.add(particles)
        self.instance.append(self)


class Player(MovingActor):
    def __init__(self, x, y, planet):
        super(Player, self).__init__(x, y, 16)
        self.planet = planet
        self.rotation_speed =1
        self.linear_speed = 80
        self.direction = eu.Vector2(0, 0)
        self.particles = ps.Meteor()
        self.particles.size = 50
        self.add(self.particles)

    def update(self, dt):
        if self.planet is not None:
            super(Player, self).update(dt)
            gx = 20 * math.cos(self.angle)
            gy = 20 * math.sin(self.angle)
            self.particles.gravity = eu.Point2(gx, -gy)
        else:
            self.position += self.direction * dt

    def switch(self):
        new_dir = eu.Vector2(self.y - self.planet.y,
                         self.planet.x - self.x)
        self.direction = new_dir.normalized() * self.linear_speed
        self.planet = None
        self.particles.gravity = eu.Point2(-self.direction.x,
                                           -self.direction.y)


class PickupParticles(ps.Sun):
    size = 20
    start_color = ps.Color(0.7, 0.7, 0.2, 1.0)


class Pickup(MovingActor):
    def __init__(self, x, y, planet):
        super(Pickup, self).__init__(x, y, 10)
        self.planet = planet
        self.gravity_factor = 50
        self.particles = PickupParticles
        self.add(self.particles)


class Enemy(Actor):
    def __init__(self, x, y, target):
        super(Enemy, self).__init__(x, y, 40)
        self.velocity = eu.Vector2(0, 0)
        self.speed = 2
        self.max_force = 5
        self.max_velocity = 30
        self.max_ahead = 300
        self.max_avoid_force = 500
        self.target = target
        self.add(ps.Sun())
        self.schedule(self.update)


    def update(self, dt):
        if self.target is None:
            return
        distance = self.target.position - eu.Vector2(self.x, self.y)
        steering = distance * self.speed - self.velocity
        steering += self.avoid_force()
        steering = truncate(steering, self.max_force)
        self.velocity = (self.velocity + steering, self.max_velocity)
        self.position += self.velocity * dt

    def avoid_force(self):
        avoid = eu.Vector2(0, 0)
        ahead = self.velocity * self.max_ahead / self.max_velocity
        l = ahead.dot(ahead)
        if l == 0:
            return avoid
        closest, closest_dist = None, None
        for obj in Planet.instances:
            w = eu.Vector2(obj.x - self.x, obj.y - self.y)
            t = ahead.dot(w)
            if 0 < t < l:
                proj = self.position + ahead * t / l
                dist = abs(obj.cshape.r - proj)
                if dist < obj.cshape.r and \
                           (closest is None or dist < closest_dist):
                            closest, closest_dist = obj.position, dist
        if closest is not None:
            avoid = self.position + ahead - closest
            avoid = avoid.normalized() * self.max_avoid_force
        return avoid


